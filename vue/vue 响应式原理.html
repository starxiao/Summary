vue 响应式原理

1. 数据驱动: 数据修改的时候如何更新DOM。
	
	1.1 需要修改哪些DOM，如何修改，每次数据更新都要更新DOM？

2. 原理

	2.1 利用了Object.defineProperty设置getter、setter方法

	2.2 getter方法：收集了该属性在哪些地方使用，也就是依赖收集。

	2.3 setter方法：当数据更新的时候，找到这些依赖，然后进行修改，也就是派发更新。

	2.4 派发更新：将更新的数据放到一个队列中，发生在下一tick。所以数据更新到反应到DOM节点上市一个异步过程，更新之后会触发Vue.nextTick函数。

3. data、props

	3.1 在初始化的data，props会是响应式的，但是在初始化data之后添加到data上的新属性就不是响应式了。需要使用Vue.set(data,key,value)手动设置响应式的。

	3.2 array是遍历了数组的每一个值，然后设置响应式。但修改数组的长度，arr[0] = value不是响应式的。

	3.3 array响应式的方法: push,pop,shfit,unshift,splice,sort,reverse

	3.4 data在vue的实例中可以是obj|function,在组件中必须是function

		因为组件是可以复用的，如果data是个对象，data被所有通过这个构造函数创建的实例所共享，每个组件实例会相互影响。

	3.5 new Vue() VS Vue.extend() VS Vue.component()

		new Vue()  -> 创建一个Vue实例,里面的data可以是对象，因为创造一个新的实例。不会相互影响

		Vue.extend({})   -> Vue的子类继承方法，返回的是一个构造函数(并不是Vue实例)。data只能是函数。
		<script type="text/javascript">
			const component = Vue.extend({
				data(){
					return{
						data: 1
					}
				}
			});
			const page = Vue.component('page-component',component);	
			const page1 = new component();
		</script>

		Vue.component('page-component',option)   -> option里面的data也必须是函数，Vue会先用Vue.extend(option)创建一个构造函数。

		<script type="text/javascript">
			function Fun(option){
				this.option = option;
			}

			Fun.prototype.data = {
				a: 1
			}

			let a = new Fun({a:1});
			let b = new Fun({a:1});
			a和b的属性a相互不影响

			let obj = {a:1};
			let c = new Fun(obj);
			let d = new Fun(obj);
			c和d的属性a会相互影响

			而在Vue.extend创建的构造函数相当于在Fun.prototype属性上添加的。所以当继承的时候指向的是同一个对象。
		</script>

		而在webpack使用export default的Vue组件也是一个对象，并且这个对象的data只能是一个函数


4. 组件更新

	4.1 组将更新过程分新旧组件相同和不同。

	4.2 新旧组件相同时，查看组件的vnode diff,查看子节点具体哪不同，实现局部更新。

	4.3 新旧组件不同时，创建新节点-> 更新父占位符->删除旧节点-> 挂载

5. computed

	5.1 computed方法会监听当前依赖值的变化，当依赖值变化的时候会重新执行该方法

	5.2 computed方法常用来返回store里面的state。

	<h1>{{dataUser}}</h1>
	<h2>{{$store.state.user}}</h2>
	<h3>{{computedUser}}</h3>
	<h4>{{dataObj.user}}</h4>
	<script type="text/javascript">
		data(){
			return {
				dataUser: this.$store.state.user,
				dataObj: this.$store.state.obj
			}
		},
		computed:{
			computedUser(){
				return this.$store.state.user
			}
		}

		//1. dataUser不会与state.user进行绑定，而computedUser会，也就是当state.user变化的时候
		h1的值不会改变，h2和h3会改变

		//2. 当obj.user改变的时候，h4也会改变
	</script>

6. watch