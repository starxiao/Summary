vue 响应式原理

1. 数据驱动: 数据修改的时候如何更新DOM。
	
	1.1 需要修改哪些DOM，如何修改，每次数据更新都要更新DOM？

2. 原理

	2.1 利用了Object.defineProperty设置getter、setter方法

	2.2 getter方法：收集了该属性在哪些地方使用，也就是依赖收集。

	2.3 setter方法：当数据更新的时候，找到这些依赖，然后进行修改，也就是派发更新。

	2.4 派发更新：将更新的数据放到一个队列中，发生在下一tick。所以数据更新到反应到DOM节点上市一个异步过程，更新之后会触发Vue.nextTick函数。

3. data、props

	3.1 在初始化的data，props会是响应式的，但是在初始化data之后添加到data上的新属性就不是响应式了。需要使用Vue.set(data,key,value)手动设置响应式的。

	3.2 array是遍历了数组的每一个值，然后设置响应式。但修改数组的长度，arr[0] = value不是响应式的。

	3.3 array响应式的方法: push,pop,shfit,unshift,splice,sort,reverse

4. 组件更新

	4.1 组将更新过程分新旧组件相同和不同。

	4.2 新旧组件相同时，查看组件的vnode diff,查看子节点具体哪不同，实现局部更新。

	4.3 新旧组件不同时，创建新节点-> 更新父占位符->删除旧节点-> 挂载

5. computed

	5.1 computed方法会监听当前依赖值的变化，当依赖值变化的时候会重新执行该方法

	5.2 computed方法常用来返回stote里面的state。

	<h1>{{dataUser}}</h1>
	<h2>{{$store.state.user}}</h2>
	<h3>{{computedUser}}</h3>
	<h4>{{dataObj.user}}</h4>
	<script type="text/javascript">
		data(){
			return {
				dataUser: this.$store.state.user,
				dataObj: this.$store.state.obj
			}
		},
		computed:{
			computedUser(){
				return this.$store.state.user
			}
		}

		1. dataUser不会与state.user进行绑定，而computedUser会，也就是当state.user变化的时候
		h1的值不会改变，h2和h3会改变

		2. 当obj.user改变的时候，h4也会改变
	</script>

6. watch